%%  fillInFourierGrid_tomo_C %%

%%inputs:
%%  projections - measured projections
%%  angles - Euler angles in the form 3xN_projections, where each projection has 3 angles in the form [phi;theta;psi]
%%  interpolationCutoffDistance - radius of sphere in which to include measured
%%  oversamplingRatioX(Y) - oversampling ratio for the projections in X (Y) direction
%%      values when filling in grid. All points within this sphere will be weighted
%%      linearly by their inverse distance. 

%%  confidenceWeightVector - confidence weighting for grid points. Initialize to ones to use all data equally
%%  doCTFcorrection - flag to correct for Contrast Transfer Function (CTF) in projections, requires CTFparameters
%%  CTFparameters - structure containing defocus values and defocus angle for each projection

%%outputs:
%%  rec - inverse FFT of the assembled Fourier grid
%%  measuredK -assembled Fourier Grid
%%  constraintConfidenceWeights - effective confidence value for each grid point
%%  weightedDistances - weight-averaged distance for experimental values used to compute each grid point
%%  sigmaPhases - standard deviation of phases at each gridded voxel; useful for discarding poor quality datapoints

%% Author: AJ Pryor
%% Jianwei (John) Miao Coherent Imaging Group
%% University of California, Los Angeles
%% Copyright (c) 2015. All Rights Reserved.


function [rec, measuredK, constraintConfidenceWeights, weightedDistances, sigmaPhases] = fillInFourierGrid_tomo_C(projections,angles,oversamplingRatioX,oversamplingRatioY,interpolationCutoffDistance,confidenceWeightVector,doCTFcorrection,CTFparameters)
if mod(size(projections,2),2)==1 || mod(size(projections,1),2)==1
   error('Dimensions of projections must be even. They can be different, but must be even in current implementation.')
end

if ~doCTFcorrection
   CTFparameters = []; 
end

if doCTFcorrection && nargin < 6
    error('GENFIRE: doCTFcorrection is turned on, but CTFparameters was not provided.\n\n')
end



[dimx, dimy, numProj] = size(projections);
%calculate padding parameters for the inputted window size
% paddingY = round(dimy*(oversamplingRatio-1)/2);
% paddingX = round(dimx*(oversamplingRatio-1)/2);

centralPixelY = size(projections,2)/2+1;
centralPixelX = size(projections,1)/2+1;


bigX = round(dimx*oversamplingRatioX);
if mod(bigX,2)==1;
    bigX = bigX+1;
end

bigY = round(dimy*oversamplingRatioY);
if mod(bigY,2)==1;
    bigY = bigY+1;
end

paddingX = (bigX-size(projections,1))/2;
paddingY = (bigY-size(projections,2))/2;

% halfWindowSize = particleWindowSize/2;
halfWindowSizeY = size(projections,2)/2;
halfWindowSizeX = size(projections,1)/2;

kMeasured = zeros(bigX,bigY,numProj);

tic
confidenceWeightVector(confidenceWeightVector<0) = 0;%weights are generated by Fourier Ring Correlation, so set negatively correlated values to 0 weighting (no confidence)
[dim1 dim2 dim3] = size(kMeasured);
ncy = single(round((dim2+1)/2));%center pixel
ncx = single(round((dim1+1)/2));%center pixel
n2y = single(ncy-1);%radius of array
n2x = single(ncx-1);%radius of array

[ky, kx] = meshgrid(-n2y:n2y-1,-n2x:n2x-1);ky = single(ky);kx = single(kx);
Q = sqrt((ky./n2y).^2+(kx./n2x).^2);
% Q = sqrt(ky.^2+kx.^2);

kx = single(kx(:))'; ky = single(ky(:))'; %initialize coordinates of unrotate projection slice
kz = zeros(1,dim1*dim2,'single'); %0 degree rotation is a projection onto the X-Y plane, so all points have kz=0;


if isfield(CTFparameters,'throwOutThreshhold')
    throwOutThreshhold = CTFparameters(1).throwOutThreshhold; %value below which to not grid points that were suppressed by the CTF
else
    throwOutThreshhold = 0.00;%default value
end

if doCTFcorrection

    if isfield(CTFparameters,'ignore_first_peak')
       ignore_first_peak =  CTFparameters(1).ignore_first_peak;
    else
        ignore_first_peak = 0;
    end
    

for projNum = 1:size(projections,3);
    %get Contrast Transfer Function (CTF)
    %CTF = ctf_correction(projections(:,:,projNum),CTFparameters(projNum).defocusU,CTFparameters(projNum).defocusV,CTFparameters(projNum).defocusAngle,ignore_first_peak);
    % tmp = projections(496-212:496+211,496-212:496+211,projNum);   
    %     
    %     tmp = projections(centralPixel-212:centralPixel+211,centralPixel-212:centralPixel+211,projNum);      
%     tmp = projections(:,:,projNum); 
%     tmp = padarray(tmp,[size(tmp,1)/2 size(tmp,2)/2]);%this padding is for accuracy of CTF correction
%     
% 
%     pjK = my_fft(tmp);%take forward FFT

    pjK = projections(:,:,projNum);
    centralPixelK = size(pjK,2)/2+1;
    pjK = pjK(centralPixelK-halfWindowSize:centralPixelK+halfWindowSize-1,centralPixelK-halfWindowSize:centralPixelK+halfWindowSize-1);%window projection

    pjK = my_fft(padarray(pjK,[padding padding 0]));%pad and take FFT
    [CTF, gamma] = ctf_correction(pjK,CTFparameters(projNum).defocusU,CTFparameters(projNum).defocusV,CTFparameters(projNum).defocusAngle,ignore_first_peak);%get CTF
    if CTFparameters(projNum).phaseFlip %this should always be on unless your projections have already been CTF corrected elsewhere
        pjK(CTF<0) = -1*pjK(CTF<0);%phase flip
    end
    
    if CTFparameters(projNum).correctAmplitudesWithWienerFilter
        dim1_2 = size(CTF,1);
        nc2 = single(round((dim1_2+1)/2));%center pixel
        n22 = single(nc2-1);%radius of array

        [ky2, kx2] = meshgrid(-n22:n22-1,-n22:n22-1);ky2 = single(ky2);kx2 = single(kx2);
        Q2 = sqrt(ky2.^2+kx2.^2)./n22;
        SSNR = ones(size(Q2));%make SSNR map
        
        SSNR(:) = interp1(linspace(0,1+1e-10,size(CTFparameters(projNum).SSNR,2)),CTFparameters(projNum).SSNR,Q2(:),'linear');%make weighting map from average FRC
        SSNR(isnan(SSNR)) = 0;
        wienerFilter = abs(CTF)./(abs(CTF).^2+(1./SSNR));%construct Wiener filter for CTF amplitude correction
        pjK = pjK.*wienerFilter; 
    elseif CTFparameters(projNum).multiplyByCTFabs%multiplying by CTF boosts SNR and is most useful for datasets that are extremely noisy
        pjK = pjK.*abs(CTF); 
    end
    


    
    if throwOutThreshhold>0 %recalculate CTF at new array size for throwing out values that were near CTF 0 crossover
%         CTF = ctf_correction(pjK,CTFparameters(projNum).defocusU,CTFparameters(projNum).defocusV,CTFparameters(projNum).defocusAngle,ignore_first_peak);%get CTF
        pjK(abs(CTF)<throwOutThreshhold & (gamma>(pi/2))) = -999;%flag values where CTF was near 0 to ignore for gridding, but ignore out to first peak
    end
    
    kMeasured(:,:,projNum) = pjK;   
end
   
else
    
    if throwOutThreshhold > 0
        
        for projNum = 1:size(projections,3);
            pjK = projections(centralPixelK-halfWindowSize:centralPixelK+halfWindowSize-1,centralPixelK-halfWindowSize:centralPixelK+halfWindowSize-1,projNum);
            pjK = my_fft(padarray(pjK,[padding padding 0]));
            CTF = ctf_correction(pjK,CTFparameters(projNum).defocusU,CTFparameters(projNum).defocusV,CTFparameters(projNum).defocusAngle,ignore_first_peak);%get CTF
            pjK(abs(CTF)<throwOutThreshhold) = -999;%flag values where CTF was near 0 to ignore for gridding
            kMeasured(:,:,projNum) = pjK;

        end
        
    else
        
        for projNum = 1:size(projections,3);
            kMeasured(:,:,projNum) = my_fft(padarray(projections(centralPixelX-halfWindowSizeX:centralPixelX+halfWindowSizeX-1,centralPixelY-halfWindowSizeY:centralPixelY+halfWindowSizeY-1,projNum),[paddingX paddingY  0]));
        end
        
        
    end
   
end
% kMeasured = projections;
clear projections

%initialize arrays to contain coordinates
measuredX = zeros(1,size(kMeasured,2)*size(kMeasured,1),size(kMeasured,3),'single');
measuredY = zeros(1,size(kMeasured,2)*size(kMeasured,1),size(kMeasured,3),'single');
measuredZ = zeros(1,size(kMeasured,2)*size(kMeasured,1),size(kMeasured,3),'single');

%initialize arrays
% kMeasured = zeros(dim1,dim1,size(projections,3),'single');
% confidenceWeights = zeros(dim1,dim1,size(projections,3),'single');
measuredK = zeros(dim1,dim2,dim1,'single');
constraintConfidenceWeights = zeros(dim1,dim2,dim1,'single');

%initialize array for measured Fourier points
% kMeasured = zeros(dim1,dim1,size(projections,3),'single');


% confidenceWeights = zeros(dim1,dim1,size(projections,3),'single');
confidenceWeights = zeros(dim1,dim2,size(kMeasured,3),'single');

% for projNum = 1:size(projections,3);
for projNum = 1:size(kMeasured,3);
phi = angles(projNum,1);
theta = angles(projNum,2);
psi = angles(projNum,3);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   OUTDATED -- EST convention(also old GENFIRE convention)
% % rotation matrix (by preference it operates on vectors [y;x;z] NOT [x;y;z].
% % I prefer this way because in MATLAB the first index corresponds to the row
% % which I find more natural to consider the y-axis

% R = [ -sind(psi)*sind(phi)+cosd(theta)*cosd(phi)*cosd(psi)  -sind(psi)*cosd(phi)-cosd(theta)*sind(phi)*cosd(psi) cosd(psi)*sind(theta) ;...
%       cosd(psi)*sind(phi)+cosd(theta)*cosd(phi)*sind(psi) cosd(psi)*cosd(phi)-cosd(theta)*sind(phi)*sind(psi) sind(psi)*sind(theta); ...
%     -sind(theta)*cosd(phi) sind(theta)*sind(phi) cosd(theta)];
%     tmpTheta = acosd(R(3,3));
%     if tmpTheta == 0
%         tmpPsi = 0;
%         tmpPhi = atan2d(-R(1,2),R(2,2));
%     else
%         tmpPhi = atan2d(R(3,2),-R(3,1));
%         tmpPsi = atan2d(R(2,3),R(1,3));
%     end 
% [ky kz] = meshgrid(-n2:n2-1,-n2:n2-1);
% Q = sqrt(ky.^2+kz.^2)./n2;
% kz = single(kz(:))'; ky = single(ky(:))'; %initialize coordinates of unrotate projection slice
% kx = zeros(1,dim1*dim1,'single'); %0 degree rotation is a projection onto the Y-Z plane, so all points have kx=0;
% rotkCoords = R*[ky;kx;kz];%rotate coordinates

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  GENFIRE/RELION/XMIPP/FREALIGN/EMAN convention:
% % 
% R = [-sind(psi)*cosd(theta)*sind(phi)+cosd(psi)*cosd(phi), -sind(psi)*cosd(theta)*cosd(phi)-cosd(psi)*sind(phi), sind(psi)*sind(theta);
%   cosd(psi)*cosd(theta)*sind(phi)+sind(psi)*cosd(phi) , cosd(psi)*cosd(theta)*cosd(phi)-sind(psi)*sind(phi) ,-cosd(psi)*sind(theta);
% sind(theta)*sind(phi), sind(theta)*cosd(phi),cosd(theta)];


% tmpTheta = acosd(R(3,3));
% if tmpTheta==0
%     tmpPhi = 0;
%     tmpPsi = atan2d(-R(1,2),R(2,2));
% else
%     tmpPhi = atan2d(R(3,1),R(3,2));
%     tmpPsi = atan2d(R(1,3),-R(2,3));
% end

R = [ cosd(psi)*cosd(theta)*cosd(phi)-sind(psi)*sind(phi) ,cosd(psi)*cosd(theta)*sind(phi)+sind(psi)*cosd(phi)   ,    -cosd(psi)*sind(theta);
      -sind(psi)*cosd(theta)*cosd(phi)-cosd(psi)*sind(phi), -sind(psi)*cosd(theta)*sind(phi)+cosd(psi)*cosd(phi) ,   sind(psi)*sind(theta)  ;
      sind(theta)*cosd(phi)                               , sind(theta)*sind(phi)                                ,              cosd(theta)];

% tmpTheta = acosd(R(3,3));
% if tmpTheta==0
%     tmpPhi = 0;
%     tmpPsi = atan2d(-R(2,1),R(1,1));
% else
%     tmpPhi = atan2d(R(3,2),R(3,1));
%     tmpPsi = atan2d(R(2,3),-R(1,3));
% end

  
rotkCoords = R'*[kx;ky;kz];%rotate coordinates
currentConfidenceWeights = zeros(size(Q));
% currentConfidenceWeights(:) = interp1(linspace(0,1+1e-10,size(confidenceWeightVector,2)),confidenceWeightVector(projNum,:),Q(:),'linear','extrap');%make weighting map from average FRC
currentConfidenceWeights(:) = interp1(linspace(0,1+1e-10,size(confidenceWeightVector,2)),confidenceWeightVector(projNum,:),Q(:),'linear');%make weighting map from average FRC

currentConfidenceWeights(isnan(currentConfidenceWeights))=0;%extrapolated values will be NaN and are outside the resolution circle anyway
confidenceWeights(:,:,projNum) = currentConfidenceWeights;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

measuredX(:,:,projNum) = rotkCoords(1,:);%rotated X
measuredY(:,:,projNum) = rotkCoords(2,:);%rotated Y
measuredZ(:,:,projNum) = rotkCoords(3,:);%rotated Z
% tmp = my_fft(projections(:,:,projNum));
% kMeasured(:,:,projNum) = tmp; %track complex value at that point


end

%reshape to simplify
measuredX = reshape(measuredX,1,size(kMeasured,2)*size(kMeasured,1)*size(kMeasured,3));
measuredY = reshape(measuredY,1,size(kMeasured,2)*size(kMeasured,1)*size(kMeasured,3));
measuredZ = reshape(measuredZ,1,size(kMeasured,2)*size(kMeasured,1)*size(kMeasured,3));
kMeasured = reshape(kMeasured,1,size(kMeasured,2)*size(kMeasured,1)*size(kMeasured,3));
confidenceWeights = reshape(confidenceWeights,1,size(kMeasured,2)*size(kMeasured,1)*size(kMeasured,3));
badInd = find(kMeasured==-999);%delete values that are flagged as bad
measuredX(badInd) = [];
measuredY(badInd) = [];
measuredZ(badInd) = [];
kMeasured(badInd) = [];
confidenceWeights(badInd) = [];

masterInd = [];%masterInd will be a large list of the grid indices
masterVals = [];%complex values to include in weighted averaging for those grid points
masterDistances = [];%distance from measured value to grid point
masterConfidenceWeights = [];
%shiftMax = round(interpolationCutoffDistance);
 shiftMax = 0;
%The nearest grid point to a measured value can be found by rounding, but
%there can be more than one grid point within the cutoff sphere, so must
%search locally for other possibilities. However in practice I have found 
%this search can slow the program down greatly, without significant change
%in final result. Even searching 1 voxel in either direction increases the
%number of calculations by 3^3 = 27; For this reason I often set shiftMax = 0 and
%just assign values to their closest voxel.

for Yshift = -shiftMax:shiftMax 
   for Xshift = -shiftMax:shiftMax
       for Zshift = -shiftMax:shiftMax
            tmpX = (round(measuredX)+Xshift); % apply shift
            tmpY = (round(measuredY)+Yshift);
            tmpZ = (round(measuredZ)+Zshift);
            tmpVals = kMeasured;
            tmpConfidenceWeights = confidenceWeights;
            distances = sqrt(abs(measuredX-tmpX).^2+abs(measuredY-tmpY).^2+abs(measuredZ-tmpZ).^2); 
            tmpY = tmpY+ncy;
            tmpZ = tmpZ+ncx;
            tmpX = tmpX+ncx;
            goodInd = (~(tmpX>dim1|tmpX<1|tmpY>dim2|tmpY<1|tmpZ>dim1|tmpZ<1)) & distances<=interpolationCutoffDistance;
            masterInd = [masterInd sub2ind([dim1 dim2 dim1],tmpX(goodInd),tmpY(goodInd),tmpZ(goodInd))]; %append values to lists
            masterVals = [masterVals tmpVals(goodInd)];
            masterDistances = [masterDistances distances(goodInd)];
            masterConfidenceWeights = [masterConfidenceWeights tmpConfidenceWeights(goodInd)];

       end
   end
end
   
clear measuredX
clear measuredY
clear measuredZ
clear confidenceWeights
   
[masterInd sortInd] = sort(masterInd);%organize lists
masterVals = masterVals(sortInd);
masterDistances = masterDistances(sortInd);
masterConfidenceWeights = masterConfidenceWeights(sortInd);


[uniqueVals uniqueInd] = unique(masterInd);%find non repeating values

uniqueInd(end+1) = length(masterInd)+1;

diffVec = diff(uniqueInd);
singleInd = find(diffVec==1);
multiInd = find(diffVec~=1);
constraintConfidenceWeights(uniqueVals(singleInd)) = masterConfidenceWeights(uniqueInd(singleInd));
measuredK(uniqueVals(singleInd)) = masterVals(uniqueInd(singleInd)).*constraintConfidenceWeights(uniqueVals(singleInd));
if nargout>3
    weightedDistances = zeros(size(measuredK),'single');
    weightedDistances(uniqueVals(singleInd)) = (masterDistances(uniqueInd(singleInd))+1e-30).*constraintConfidenceWeights(uniqueVals(singleInd)); 
end
if nargout > 4
   sigmaPhases = zeros(size(measuredK),'single'); 
end
% if nargout>2
%     for index = 1:length(multiInd)-1
%     ind = multiInd(index);
% %     numVals(masterInd(uniqueInd(ind))) = numVals(masterInd(uniqueInd(ind))) + numel(uniqueInd(ind):uniqueInd(ind+1)-1);
%     numVals(masterInd(uniqueInd(ind))) = numVals(masterInd(uniqueInd(ind))) + (uniqueInd(ind+1)-uniqueInd(ind));
% 
%     end
% end
% for index = 1:length(multiInd)-1
%     ind = multiInd(index);
%     distances = masterDistances(uniqueInd(ind):uniqueInd(ind+1)-1)+1e-10;
%     complexVals = masterVals(uniqueInd(ind):uniqueInd(ind+1)-1);
%     weights = ((1./distances).*sum(distances)./sum((1./distances).*sum(distances)));
%     voxel_Mag = sum(weights.*abs(complexVals));
%     voxel_Phase = angle(sum(weights.*complexVals));
%     measuredK(masterInd(uniqueInd(ind))) = voxel_Mag.*exp(1i.*voxel_Phase);
%   
% end
% [weightedMagnitudes, RealValues, ComplexValues] = weightVals(double(multiInd'),double(masterDistances),double(masterVals),double(uniqueInd));
% % % % % % % % % save('dataStuff','multiInd','masterDistances','masterVals','uniqueInd','masterConfidenceWeights')
[weightedMagnitudes, RealValues, ComplexValues,weightedConfidenceWeights,weightedDistances_toAppend, sigmaPhaseVals] = weightVals(double(multiInd'),double(masterDistances),double(masterVals),double(uniqueInd),double(masterConfidenceWeights));

 weightedPhases = angle((RealValues+i*ComplexValues));
 measuredK(masterInd(uniqueInd(multiInd))) = weightedMagnitudes.*exp(1*i*weightedPhases);
%measuredK(masterInd(uniqueInd(multiInd))) = RealValues + 1i.*ComplexValues;


constraintConfidenceWeights(masterInd(uniqueInd(multiInd))) = weightedConfidenceWeights;
constraintConfidenceWeights(isnan(constraintConfidenceWeights))=0;
if nargout>3
    weightedDistances(masterInd(uniqueInd(multiInd))) = weightedDistances_toAppend; 
end
if nargout>4
   sigmaPhases(masterInd(uniqueInd(multiInd))) = sigmaPhaseVals;
end
rec = real(my_ifft(measuredK));
timeTakenToFillInGrid = toc;
timeTakenToFillInGrid = round(10*timeTakenToFillInGrid)./10;
fprintf('GENFIRE: Fourier grid assembled in %.12g seconds.\n\n',timeTakenToFillInGrid);
